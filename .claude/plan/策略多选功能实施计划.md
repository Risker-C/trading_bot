# 策略多选与权重配置功能实施计划

> **状态**: 已批准 | **创建日期**: 2026-01-19 | **执行模式**: 信号强度加权

## 执行摘要

**功能目标**：
- 支持回测系统同时选择多个策略并配置权重
- 采用信号强度加权模式：`score = Σ(weight_i × strength_i × direction_i)`
- 仅展示整体统计，交易记录标注主导策略

**技术方案**：
- 后端：在 `strategies/strategies.py` 新增 `get_weighted_signal()` 函数
- 前端：多选下拉框 + 动态权重配置列表 + 实时验证
- 数据库：复用 `strategy_params` JSON 字段，无需 schema 变更

---

## 后端实施计划（Codex 设计）

### 1. 文件清单

| 文件路径 | 修改内容 | 优先级 |
|---------|---------|--------|
| `strategies/strategies.py` | 新增 `get_weighted_signal()` 函数 | P0 |
| `backtest/engine.py` | 支持多策略参数，调用加权信号函数 | P0 |
| `apps/api/models/backtest.py` | 新增 `StrategyWeight` 模型，权重校验 | P0 |
| `apps/api/routes/backtest.py` | 传递 `strategy_params` 到回测引擎 | P0 |
| `backtest/repository.py` | 确保 JSON 字段保存完整（无需改动） | P1 |

### 2. 核心算法实现

#### 加权信号函数签名
```python
# strategies/strategies.py
def get_weighted_signal(
    df: pd.DataFrame,
    strategies: List[Dict],  # [{"name": "xxx", "weight": 0.6, "params": {...}}]
    threshold: float = 0.30
) -> Optional[TradeSignal]:
    """
    多策略信号强度加权聚合

    算法：
    1. 对每个策略计算 score = weight × strength × direction
    2. 归一化：normalized_score = Σ(score) / Σ(weight)
    3. 若 |normalized_score| >= threshold，触发交易
    4. 方向取 sign(normalized_score)
    """
    total_weight = sum(item["weight"] for item in strategies if item["weight"] > 0)
    if total_weight <= 0:
        return None

    contributions = []
    for item in strategies:
        strategy = get_strategy(item["name"], df, **item.get("params", {}))
        signal = strategy.analyze()
        if signal and signal.signal in [Signal.LONG, Signal.SHORT]:
            direction = 1 if signal.signal == Signal.LONG else -1
            strength = min(max(signal.strength, 0), 1)  # 裁剪到 [0,1]
            score = item["weight"] * strength * direction
            contributions.append((item["name"], score, strength))

    if not contributions:
        return TradeSignal(Signal.HOLD, "weighted", strength=0)

    normalized = sum(score for _, score, _ in contributions) / total_weight
    if abs(normalized) < threshold:
        return TradeSignal(Signal.HOLD, "weighted", strength=abs(normalized))

    # 主导策略：贡献最大的策略
    primary = max(contributions, key=lambda x: abs(x[1]))[0]

    return TradeSignal(
        Signal.LONG if normalized > 0 else Signal.SHORT,
        primary,  # 交易记录标注主导策略
        reason=f"weighted_signal (contributions: {contributions})",
        strength=abs(normalized),
        indicators={"contributions": contributions, "normalized": normalized}
    )
```

#### 回测引擎集成
```python
# backtest/engine.py
def run(self, session_id: str, klines: pd.DataFrame, strategy_name: str,
        strategy_params: Optional[Dict] = None, initial_capital: float = 10000.0):

    # 判断是否为多策略模式
    if strategy_params and strategy_params.get("strategies"):
        # 多策略加权模式
        for i in range(50, len(klines)):
            window = klines.iloc[i-50:i+1]
            signal = get_weighted_signal(
                window,
                strategy_params["strategies"],
                threshold=strategy_params.get("threshold", 0.30)
            )
            # ... 后续交易逻辑
    else:
        # 单策略模式（保持原有逻辑）
        strategy = get_strategy(strategy_name, window)
        signal = strategy.analyze()
        # ...
```

### 3. API 接口变更

#### 请求模型
```python
# apps/api/models/backtest.py
from pydantic import BaseModel, field_validator

class StrategyWeight(BaseModel):
    name: str
    weight: float  # 0-1 或 0-100
    params: Optional[Dict[str, Any]] = None

class CreateSessionRequest(BaseModel):
    # ... 原有字段
    strategy_name: str  # 单策略时使用
    strategies: Optional[List[StrategyWeight]] = None  # 多策略时使用
    weighted_threshold: Optional[float] = 0.30

    @field_validator('strategies')
    @classmethod
    def validate_weights(cls, v):
        if v:
            total = sum(s.weight for s in v)
            # 支持 0-1 或 0-100 两种格式
            if not (abs(total - 1.0) < 0.01 or abs(total - 100) < 0.1):
                raise ValueError(f"权重总和必须为 1.0 或 100，当前为 {total}")
        return v
```

### 4. 测试用例

```python
# tests/test_weighted_signal.py
def test_weighted_signal_long():
    """测试多策略做多信号"""
    strategies = [
        {"name": "macd_cross", "weight": 0.6},
        {"name": "ema_cross", "weight": 0.4}
    ]
    signal = get_weighted_signal(df, strategies)
    assert signal.signal == Signal.LONG
    assert signal.strategy in ["macd_cross", "ema_cross"]

def test_weight_validation():
    """测试权重校验"""
    with pytest.raises(ValueError):
        CreateSessionRequest(
            strategies=[
                StrategyWeight(name="macd", weight=0.5),
                StrategyWeight(name="ema", weight=0.3)  # 总和 0.8 ≠ 1.0
            ]
        )
```

---

## 前端实施计划（Gemini 设计）

### 1. 组件清单

| 组件名称 | 职责 | 文件路径 |
|---------|------|---------|
| `StrategyMultiSelector` | 策略多选界面（复选框列表） | 新建组件 |
| `StrategyWeightItem` | 单个策略配置行（名称+权重+移除） | 新建组件 |
| `WeightBalancePanel` | 总权重显示+均分按钮+验证提示 | 新建组件 |
| `BacktestPage` | 集成多选组件，更新 `handleStart` | 修改现有 |

### 2. 状态管理变更

```typescript
// apps/dashboard/stores/useBacktestStore.ts
interface StrategyConfig {
  name: string;
  weight: number; // 0-100
}

interface BacktestParams {
  // ... 原有字段
  strategyName: string; // 保持不变，单选时使用
  selectedStrategies: StrategyConfig[]; // 新增：多策略列表
}

// 默认状态
const initialParams = {
  // ...
  strategyName: 'bollinger_trend',
  selectedStrategies: [{ name: 'bollinger_trend', weight: 100 }],
};

// 新增 actions
const useBacktestStore = create<BacktestStore>((set) => ({
  // ...
  addStrategy: (name: string) => set((state) => ({
    params: {
      ...state.params,
      selectedStrategies: [
        ...state.params.selectedStrategies,
        { name, weight: 0 }
      ]
    }
  })),
  removeStrategy: (name: string) => set((state) => ({
    params: {
      ...state.params,
      selectedStrategies: state.params.selectedStrategies.filter(s => s.name !== name)
    }
  })),
  updateWeight: (name: string, weight: number) => set((state) => ({
    params: {
      ...state.params,
      selectedStrategies: state.params.selectedStrategies.map(s =>
        s.name === name ? { ...s, weight } : s
      )
    }
  })),
  autoBalanceWeights: () => set((state) => {
    const count = state.params.selectedStrategies.length;
    const weight = Math.floor(100 / count);
    const remainder = 100 - weight * count;
    return {
      params: {
        ...state.params,
        selectedStrategies: state.params.selectedStrategies.map((s, i) => ({
          ...s,
          weight: i === 0 ? weight + remainder : weight
        }))
      }
    };
  })
}));
```

### 3. 组件实现

#### StrategyMultiSelector
```tsx
// apps/dashboard/components/backtest/StrategyMultiSelector.tsx
import { Checkbox } from '@/components/ui/checkbox';
import { Label } from '@/components/ui/label';

const AVAILABLE_STRATEGIES = [
  { value: 'bollinger_trend', label: 'Bollinger Trend' },
  { value: 'macd_cross', label: 'MACD Cross' },
  { value: 'ema_cross', label: 'EMA Cross' },
  { value: 'composite_score', label: 'Composite Score' },
  { value: 'multi_timeframe', label: 'Multi Timeframe' },
  { value: 'adx_trend', label: 'ADX Trend' },
];

export function StrategyMultiSelector({
  selected,
  onToggle
}: {
  selected: string[];
  onToggle: (name: string) => void;
}) {
  return (
    <div className="space-y-2">
      <Label>选择策略</Label>
      <div className="grid grid-cols-2 gap-2">
        {AVAILABLE_STRATEGIES.map((strategy) => (
          <div key={strategy.value} className="flex items-center space-x-2">
            <Checkbox
              id={strategy.value}
              checked={selected.includes(strategy.value)}
              onCheckedChange={() => onToggle(strategy.value)}
            />
            <label
              htmlFor={strategy.value}
              className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
            >
              {strategy.label}
            </label>
          </div>
        ))}
      </div>
    </div>
  );
}
```

#### WeightBalancePanel
```tsx
// apps/dashboard/components/backtest/WeightBalancePanel.tsx
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';

export function WeightBalancePanel({
  strategies,
  onAutoBalance
}: {
  strategies: StrategyConfig[];
  onAutoBalance: () => void;
}) {
  const totalWeight = strategies.reduce((sum, s) => sum + s.weight, 0);
  const isValid = Math.abs(totalWeight - 100) < 0.01;

  return (
    <div className="flex items-center justify-between p-3 border rounded-lg bg-muted/30">
      <div className="flex items-center gap-2">
        <span className="text-sm font-medium">总权重：</span>
        <Badge
          variant={isValid ? "default" : "destructive"}
          className={isValid ? "bg-green-100 text-green-800 border-green-200" : ""}
        >
          {totalWeight.toFixed(1)}%
        </Badge>
      </div>
      <Button
        variant="outline"
        size="sm"
        onClick={onAutoBalance}
      >
        均分权重
      </Button>
    </div>
  );
}
```

### 4. 表单验证逻辑

```typescript
// 实时验证
const totalWeight = useMemo(() =>
  params.selectedStrategies.reduce((sum, s) => sum + s.weight, 0),
  [params.selectedStrategies]
);

const isValid = useMemo(() =>
  params.selectedStrategies.length > 0 && Math.abs(totalWeight - 100) < 0.01,
  [params.selectedStrategies, totalWeight]
);

// 提交验证
const handleStart = async () => {
  if (!isValid) {
    alert('请确保总权重为 100%');
    return;
  }

  const payload = {
    ...baseParams,
    // 单策略模式
    strategy_name: params.selectedStrategies.length === 1
      ? params.selectedStrategies[0].name
      : 'weighted_composite',
    // 多策略配置
    strategy_params: params.selectedStrategies.length > 1 ? {
      strategies: params.selectedStrategies.map(s => ({
        name: s.name,
        weight: s.weight / 100  // 转换为 0-1
      }))
    } : undefined
  };

  await axios.post(`${apiUrl}/api/backtests/sessions`, payload);
};
```

### 5. 样式设计

```tsx
// 权重配置列表
<div className="space-y-2 p-4 border rounded-lg bg-muted/30">
  {strategies.map((strategy) => (
    <div key={strategy.name} className="flex items-center gap-3 py-2 border-b last:border-0">
      <span className="flex-1 text-sm font-medium">{strategy.name}</span>
      <div className="relative w-24">
        <Input
          type="number"
          min="0"
          max="100"
          step="0.1"
          value={strategy.weight}
          onChange={(e) => updateWeight(strategy.name, parseFloat(e.target.value))}
          className="w-full text-right pr-8"
        />
        <span className="absolute right-2 top-1/2 -translate-y-1/2 text-sm text-muted-foreground">
          %
        </span>
      </div>
      <Button
        variant="ghost"
        size="sm"
        onClick={() => removeStrategy(strategy.name)}
      >
        ✕
      </Button>
    </div>
  ))}
</div>
```

---

## 实施步骤（按依赖关系排序）

### Phase 1: 后端核心逻辑（P0）
1. ✅ 在 `strategies/strategies.py` 新增 `get_weighted_signal()` 函数
2. ✅ 编写单元测试验证加权算法
3. ✅ 在 `apps/api/models/backtest.py` 新增 `StrategyWeight` 模型和权重校验

### Phase 2: 后端集成（P0）
4. ✅ 修改 `backtest/engine.py` 支持多策略参数
5. ✅ 修改 `apps/api/routes/backtest.py` 传递参数
6. ✅ 运行回测测试确认兼容性

### Phase 3: 前端状态管理（P0）
7. ✅ 更新 `useBacktestStore` 添加多策略状态和 actions
8. ✅ 实现权重验证逻辑

### Phase 4: 前端组件开发（P0）
9. ✅ 创建 `StrategyMultiSelector` 组件
10. ✅ 创建 `WeightBalancePanel` 组件
11. ✅ 修改 `BacktestPage` 集成新组件

### Phase 5: 联调与测试（P1）
12. ✅ 前后端联调测试
13. ✅ 单策略向后兼容性测试
14. ✅ 多策略回测结果验证

---

## 关键设计决策

### 1. 向后兼容策略
- 单策略时：`selectedStrategies.length === 1`，自动隐藏权重配置，权重默认 100%
- 多策略时：展开权重配置面板，强制验证总和为 100%

### 2. 数据库设计
- **无需新增字段**：复用 `strategy_params` JSON 列
- 多策略时：`strategy_name = "weighted_composite"`，配置存入 `strategy_params.strategies`

### 3. 信号聚合规则
- 强度裁剪：所有策略的 `strength` 裁剪到 [0, 1]
- 阈值判断：默认 `threshold = 0.30`，可通过 API 参数调整
- 主导策略：选择贡献最大的策略作为交易记录的 `strategy_name`

### 4. 用户体验优化
- 实时权重总和显示（绿色=100%，红色≠100%）
- "均分权重"快捷按钮（自动平摊 100%）
- 禁用按钮状态（总权重≠100% 时禁用"开始回测"）

---

## 风险与缓解措施

| 风险 | 影响 | 缓解措施 |
|------|------|---------|
| 策略信号强度尺度不一致 | 权重失真 | 强制裁剪到 [0,1] |
| 多空信号抵消导致无交易 | 回测结果异常 | 设定最小有效阈值 0.30 |
| 前端权重输入精度问题 | 总和验证失败 | 容差 ±0.01% |
| 单策略兼容性破坏 | 现有功能受影响 | 保持原有逻辑分支 |

---

## 验收标准

- [ ] 后端：`get_weighted_signal()` 单元测试通过
- [ ] 后端：多策略回测返回正确的交易记录和指标
- [ ] 前端：多选策略界面交互流畅
- [ ] 前端：权重验证实时生效
- [ ] 集成：单策略模式无回归问题
- [ ] 集成：多策略模式回测结果符合预期

---

**批准状态**：✅ 已批准
**预计完成时间**：根据实际开发进度调整
**负责人**：Claude (Orchestrator) + Codex (Backend) + Gemini (Frontend)
